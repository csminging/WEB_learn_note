<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    function Node(data,left,right) {
        this.data = data;
        this.left = left;
        this.right = right;
//        this.show = show;
    }
    Node.prototype.show = function() {
        return this.data;
    };

    function BST() {
        this.root = null;
//        this.insert = insert;
//        this.inOrder = inOrder;
    }
    BST.prototype.insert = function (data) {
        var n = new Node(data, null, null);
        if(this.root ==null) {
            this.root = n;
        }else{
            var current = this.root;
            var parent;
            while(true) {
                parent = current;
                if(data<current.data) {
                    current = current.left;
                    if(current ==null) {
                        parent.left = n;
                        break;
                    }
                }else{
                    current = current.right;
                    if(current ==null) {
                        parent.right =n;
                        break;
                    }
                }
            }
        }

    };

    //中序遍历：根据键值从小到大的遍历
    BST.prototype.inOrder= inOrder;
    function inOrder(node) {
        if(!(node==null)) {
            inOrder(node.left);
            console.log(node.show()+" ");
            inOrder(node.right);
        }
    }

    //先序遍历：先访问根节点，然后以同样的方式访问左子树和右子树。其与中序的不同仅仅是console.log()的输出位置不同
    BST.prototype.preOrder= preOrder;
    function preOrder(node) {
        if(!(node==null)) {
            console.log(node.show());
            preOrder(node.left);
            preOrder(node.right)
        }
    }

    //后序遍历：先访问叶子节点，先访问左子树，再访问右子树，同样也是输出位置不同
    BST.prototype.postOrder= postOrder;
    function postOrder(node) {
        if(!(node==null)) {
            postOrder(node.left);
            postOrder(node.right)
            console.log(node.show());
        }
    }
    //查找最小值
    BST.prototype.getMin = function() {
        var current = this.root;
        while(current.left!=null) {
            current = current.left;
        }
        return current.data;
    };
    //查找最大值
    BST.prototype.getMax = function() {
        var current = this.root;
        while(current.right!=null) {
            current = current.right;
        }
        return current.data;
    };
    //查找给定值
    BST.prototype.find = function(data) {
        var current = this.root;
        while(current!=null) {
            if(current.data==data) {
                return current;
            }else if(data<current.data) {
                current = current.left;

            }else{
                current = current.right;
            }
        }
        return null;
    };

    //删除节点,好吧，remove我还没看明白，^-^
//    BST.prototype.remove=function(data) {
//        root = removeNode(this.root, data);
//    }
//   function removeNode(node,data) {  //node,代表从哪个节点开始遍历，进行数据匹配删除
//       if(node ==null) {
//           return null;
//       }
//       if(data ==node.data) {
//           if(node.left ==null&&node.right==null) {
//               return null;
//           }
//           if(node.left ==null) {
//               return node.right;
//           }
//           if(node.right ==null) {
//               return node.left;
//           }
//           var tempNode = getSmallest(node.right);
//           node.data = tempNode.data;
//           node.right = removeNode(node.right, tempNode.data);
//           return node;
//       }else if(data<node.data) {
//           node.left = removeNode(node.left, data);
//           return node;
//       }else{
//           node.right = removeNode(node.right, data);
//           return node;
//       }
//
//   }
    var nums = new BST();
    nums.insert(23);
    nums.insert(45);
    nums.insert(16);
    nums.insert(37);
    nums.insert(3);
    nums.insert(99);
    nums.insert(22);
    console.log(nums.getMax())
    nums.remove(23);
//    console.log(nums.inOrder(nums.root));
</script>
</body>
</html>